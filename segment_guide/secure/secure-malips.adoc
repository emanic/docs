// WE PULL THIS CONTENT FROM https://github.com/aporeto-inc/junon
// DO NOT EDIT THIS FILE.
// YOU MUST SUBMIT A PR AGAINST THE UPSTREAM REPO.
// THE UPSTREAM REPO IS CURRENTLY PRIVATE.

== Blocking malicious IPs

=== About blocking connections with malicious IPs

We leverage https://github.com/stamparm/ipsum[IPsum] for this procedure,
a threat intelligence feed based on more than 30 publicly available
lists of suspicious and/or malicious IP addresses. The list is updated
once daily.

The following steps guide you through creating:

* *An automation* that creates and updates an external network with the
latest malicious IP addresses from IPsum
* *A network policy* that blocks processing units from initiating or
accepting connections with the malicious IP addresses

Because network policies that reject traffic take precedence over those
that accept it, the one we create in this procedure wonâ€™t conflict with
any other network policies you may have in place. You can safely
propagate it to children namespaces and apply it to all processing
units.

=== Prerequisites

* `apoctl` installed
* An `APOCTL_NAMESPACE` environment variable set to the target namespace
* Authenticated to `apoctl` with the *Namespace Administrator* role.

=== Creating the automation

[arabic]
. Use the following command to add an automation that creates a new
external network called `malicious-ips` and keeps it synchronized with
IPsum.
+
[source,console]
----
cat <<EOF | apoctl api create automation -f -
name: create-and-update-malicious-ip-list
trigger: Time
schedule: "@every 12h"
immediateExecution: true
disabled: false

parameters:
 serviceName: "malicious-ips"
 servicePorts: ["tcp/1:65535"]

entitlements:
 externalnetwork:
   - retrieve-many
   - create
   - delete

condition: |
 function when(api, params) {
   return {continue: true, payload: null};
 }

actions:
 - |
   function then(api, params, payload) {
     serviceName = params.serviceName
     obj = aporeto.http('GET', 'https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt');

     lines = obj.body.split('\n');

     var maliciousIPs = [];
     for (i=0; i < lines.length; i++) {
       if (lines[i].slice(0,1) != "#")  {
         var parts = lines[i].split(/\s+/);
         if ( parseInt(parts[1]) > 8 ) {
           maliciousIPs.push(parts[0]+"/32")
         } else {
           break;
         }
       }
     }

     if (maliciousIPs.length > 0 ) {
       var definedServices = api.RetrieveMany('externalnetwork', null, 'name == '+serviceName);
       if (definedServices.length > 0) {
         api.Delete('externalnetwork', definedServices[0].ID)
       }
       api.Create('externalnetwork', {
         name: serviceName,
         description: "Automatically updated malicious IP list"
         protocol: params.protocols,
         entries: maliciousIPs,
         ports: params.ports,
         propagate: true,
         associatedTags : [
           "ext:name=malicious-ips",
         ]
       })
     }
   }
EOF
----
. Copy the alphanumeric string returned by Segment Console to your
clipboard. This is the ID of the automation.
. Use the following command to retrieve the automation, replacing
`<automation-id>` with the value you copied in the previous step.
+
[source,console]
----
apoctl api get automations <automation-id>
----
. It should return a JSON object representing the automation. Check the
`errors` key. It should not contain any value.
. In the Segment Console web interface, expand *Network Authorization*
and select *External Networks*. You should see an external network named
`malicious-ips`.

=== Blocking connections with network policy

[arabic]
. Set an environment variable named `PUSELECTOR` containing the tag or
tag expression defining the processing units that should be blocked from
connecting to the malicious IPs. The following example sets the value to
`$identity=processingunit`, which will select all processing units in
the namespace. Feel free to modify this value as desired.
+
[source,console]
----
export PUSELECTOR="\$identity=processingunit"
----
. Use the following command to create the network policy.
+
[source,console]
----
cat <<EOF | apoctl api create networkaccesspolicy -f -
name: block-malicious-ips
description: Block connections with malicious IPs
action: Reject
propagate: true
subject:
  - - ext:name=malicious-ips
object:
  - - "$PUSELECTOR"
EOF
----
. In the Segment Console web interface, expand *Network Authorizations*
and select *Network Policies*. You should see a network policy named
`block-malicious-ips`.

=== Verifying the policy

[arabic]
. Spin up a simple nginx web server container on a host equipped with
the Segment defender.
+
[source,console]
----
sudo docker run --rm -d -p 80:80 nginx
----
. Open the *Platform* pane of the Segment Console web interface. You
should see the nginx web server as a processing unit.
. Obtain your public IP address, such as by visiting `whatsmyip.org` in
your browser.
. In the Segment Console web interface, expand *Network Authorization*
and select *External Networks*. Click the *Edit* button to open the
`malicious-ips` external network for editing.
. Click *Next*.
. Paste your public IP address into the *Network Information* field,
click *Next*, and then click *Update*.
. Use the following command to curl the nginx web server. Replace
`<public-ip>` with the public IP address of the defender host.
+
[source,console]
----
curl http://<public-ip>
----
+
It should time out after a while.
. Returning to the Segment Console web interface, click *Platform*.
. You should see the `malicious-ips` external network with a red flow to
your nginx processing unit. Click the red flow and select *Policies*.
Your `block-malicous-ips` policy should be listed as having blocked the
traffic.
+
Congratulations! You have successfully blocked your processing units
from communicating with IP addresses known to be malicious or
suspicious. You may want to spin down the nginx server and remove your
public IP address from the `malicious-ips` external network.
