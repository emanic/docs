== core/policy

=== ClauseMatch

This API allows to pass a set of tags and find the objects that would
match the clause in a policy resolution.

==== Example

[source,json]
----
{
  "clauses": [
    [
      "color=blue",
      "size=big"
    ],
    [
      "color=red"
    ]
  ],
  "targetIdentity": "processingunit"
}
----

==== Relations

===== `POST /clausesmatches`

Performs a clause matching.

==== Attributes

===== `clauses` `[][]string` [`required`]

The tag clause to resolve.

===== `match` `[]map[string]interface{}` [`autogenerated`,`read_only`]

Contains the matched objects.

===== `targetIdentity` `string` [`required`]

The identity to render the clauses from.

=== EnforcerRefresh

Sent to client when a poke has been triggered using the parameter
`?notify=true`. This is used by instances of enforcerd to notify an
external change on the processing unit must be processed.

==== Example

[source,json]
----
{
  "debug": "Counters"
}
----

==== Relations

===== `POST /enforcers/:id/enforcerrefreshes`

Sends a defender refresh command.

==== Attributes

===== `ID` `string` [`identifier`,`read_only`]

Contains the ID of the target defender.

===== `debug` `enum(Counters | Logs | Packets | PUState | Pcap | CoreDump)`

Set the debug information collected by the defender.

Default value:

[source,json]
----
"Counters"
----

===== `debugID` `string`

Can be used to correlate with a DebugBundle.

===== `debugPcapFilter` `string`

Packet capture filter, syntax varying by platform.

===== `debugProcessingUnitID` `string`

Isolates debug information to a given processing unit, where possible.

===== `namespace` `string` [`autogenerated`,`read_only`]

Contains the original namespace of the defender.

=== Policy

Represents the policy primitive used by all Segment policies.

==== Example

[source,json]
----
{
  "disabled": false,
  "fallback": false,
  "name": "the name",
  "propagate": false,
  "propagationHidden": false,
  "protected": false,
  "type": "APIAuthorization"
}
----

==== Relations

===== `GET /policies`

Retrieves the list of policy primitives.

Parameters:

* `q` (`string`): Filtering query. Consequent `q` parameters will form
an or.
* `propagated` (`boolean`): Also retrieve the objects that propagate
down.

===== `DELETE /policies/:id`

Deletes the object with the given ID.

Parameters:

* `q` (`string`): Filtering query. Consequent `q` parameters will form
an or.

===== `GET /policies/:id`

Retrieves the object with the given ID.

==== Attributes

===== `ID` `string` [`identifier`,`autogenerated`,`read_only`]

Identifier of the object.

===== `action` `map[string]map[string]interface{}`

Defines a set of actions that must be enforced when a dependency is met.

===== `activeDuration` `string` [`format=^[0-9]+[smh]$`]

Defines for how long the policy will be active according to the
`activeSchedule`.

===== `activeSchedule` `string`

Defines when the policy should be active using the cron notation. The
policy will be active for the given `activeDuration`.

===== `annotations` `map[string][]string`

Stores additional information about an entity.

===== `associatedTags` `[]string`

List of tags attached to an entity.

===== `createTime` `time` [`autogenerated`,`read_only`]

Creation date of the object.

===== `description` `string` [`max_length=1024`]

Description of the object.

===== `disabled` `boolean`

Defines if the property is disabled.

===== `expirationTime` `time`

If set the policy will be automatically deleted at the given time.

===== `fallback` `boolean`

Indicates that this is fallback policy. It will only be applied if no
other policies have been resolved. If the policy is also propagated it
will become a fallback for children namespaces.

===== `metadata` `[]string` [`creation_only`]

Contains tags that can only be set during creation, must all start with
the `@' prefix, and should only be used by external systems.

===== `name` `string` [`required`,`max_length=256`]

Name of the entity.

===== `namespace` `string` [`autogenerated`,`read_only`]

Namespace tag attached to an entity.

===== `normalizedTags` `[]string` [`autogenerated`,`read_only`]

Contains the list of normalized tags of the entities.

===== `object` `[][]string`

Represents set of entities that another entity depends on. As subjects,
objects are identified as logical operations on tags when a policy is
defined.

===== `propagate` `boolean`

Propagates the policy to all of its children.

===== `propagationHidden` `boolean`

If set to `true` while the policy is propagating, it wonâ€™t be visible to
children namespace, but still used for policy resolution.

===== `protected` `boolean`

Defines if the object is protected.

===== `relation` `[]string`

Describes the required operation to be performed between subjects and
objects.

===== `subject` `[][]string`

Represents sets of entities that will have a dependency other entities.
Subjects are defined as logical operations on tags. Logical operations
can include `AND` and `OR`.

===== `type` `enum(APIAuthorization | AuditProfileMapping | EnforcerProfile | File | Hook | HostServiceMapping | Infrastructure | NamespaceMapping | Network | ProcessingUnit | Quota | Service | ServiceDependency | Syscall | TokenScope | SSHAuthorization | UserAccess)` [`creation_only`]

Type of the policy.

===== `updateTime` `time` [`autogenerated`,`read_only`]

Last update date of the object.

=== PolicyRefresh

Sent to a client as a push event when a policy refresh is needed on
their side.

==== Attributes

===== `sourceID` `string`

Contains the original ID of the updated object.

===== `sourceNamespace` `string`

Contains the original namespace of the updated object.

===== `type` `string`

Contains the policy type that is affected.

=== PolicyRule

Allows services to retrieve a policy resolution (internal).

==== Example

[source,json]
----
{
  "name": "the name",
  "propagated": false
}
----

==== Relations

===== `GET /policyrules/:id`

Retrieves the object with the given ID.

==== Attributes

===== `ID` `string` [`identifier`,`autogenerated`,`read_only`]

Identifier of the object.

===== `action` `map[string]map[string]interface{}`

Defines set of actions that must be enforced when a dependency is met.

===== `auditProfiles` link:#auditprofile[`[]auditprofile`]

Provides the audit profiles that must be applied.

===== `enforcerProfiles` link:#enforcerprofile[`[]enforcerprofile`]

Provides information about the defender profile.

===== `externalNetworks` link:#externalnetwork[`[]externalnetwork`]

Provides the external network that the policy targets.

===== `filePaths` link:#filepath[`[]filepath`]

Provides the file paths that the policy targets.

===== `hostServices` link:#hostservice[`[]hostservice`]

Provides the list of host services that must be instantiated.

===== `isolationProfiles` link:#isolationprofile[`[]isolationprofile`]

Provides the isolation profiles of the rule.

===== `name` `string` [`required`,`max_length=256`]

Name of the entity.

===== `namespaces` link:#namespace[`[]namespace`]

The namespace that the policy targets.

===== `policyNamespace` `string`

The namespace of the policy that created this rule.

===== `policyUpdateTime` `time`

Last time the policy was updated.

===== `propagated` `boolean`

Indicates if the policy is propagated.

===== `relation` `[]string`

Describes the required operation to be performed between subjects and
objects.

===== `services` link:#service[`[]service`]

Provides the services of this policy rule.

===== `tagClauses` `[][]string`

Policy target tags.

=== ProcessingUnitRefresh

Sent to client when a poke has been triggered using the parameter
`?notify=true`. This is used by instances of enforcerd to notify an
external change on the processing unit must be processed.

==== Example

[source,json]
----
{
  "debug": false,
  "pingEnabled": false,
  "pingIterations": 1,
  "pingMode": "Auto",
  "refreshPolicy": false,
  "traceApplicationConnections": false,
  "traceDuration": "10s",
  "traceIPTables": false,
  "traceNetworkConnections": false
}
----

==== Relations

===== `POST /processingunits/:id/processingunitrefreshes`

Sends a Processing Unit Refresh command.

==== Attributes

===== `ID` `string` [`identifier`,`read_only`]

Contains the ID of the target processing unit.

===== `debug` `boolean`

If set to true, start reporting debug information for the target
processing unit.

===== `namespace` `string` [`autogenerated`,`read_only`]

Contains the original namespace of the processing unit.

===== `pingAddress` `string`

Destination address to run ping.

===== `pingEnabled` `boolean`

If set to true, start ping to the destination.

===== `pingIterations` `integer` [`min_value=1.000000`]

Number of iterations to run a ping probe.

Default value:

[source,json]
----
1
----

===== `pingMode` `enum(Auto | L3 | L4 | L7)`

Represents the mode of ping to be used.

Default value:

[source,json]
----
"Auto"
----

===== `pingPort` `integer`

Destination port to run ping.

===== `refreshID` `string` [`read_only`]

ID unique per purefresh event.

===== `refreshPolicy` `boolean`

If set to true, the target Processing Unit will refresh its policy
immediately.

===== `traceApplicationConnections` `boolean`

Instructs the defender to send records for all application-initiated
connections for the target processing unit.

===== `traceDuration` `string`

Determines the length of the time interval that the trace must be
enabled, using https://golang.org/pkg/time/#example_Duration[Golang
duration syntax].

Default value:

[source,json]
----
"10s"
----

===== `traceIPTables` `boolean`

Instructs the defenders to provide an iptables trace for the target
processing unit.

===== `traceNetworkConnections` `boolean`

Instructs the defender to send records for all network-initiated
connections for the target processing unit.

=== RenderedPolicy

Retrieve the aggregated policies applied to a particular processing
unit.

==== Example

[source,json]
----
{
  "processingUnit": "{
  \"name\": \"pu\",
  \"type\": \"Docker\",
  \"normalizedTags\": [
    \"a=a\",
    \"b=b\"
  ]
}"
}
----

==== Relations

===== `POST /renderedpolicies`

Render a policy for a processing unit.

Parameters:

* `csr` (`string`): CSR to sign.

===== `GET /processingunits/:id/renderedpolicies`

Retrieves the policies for the processing unit.

Parameters:

* `csr` (`string`): CSR to sign.

==== Attributes

===== `certificate` `string` [`read_only`]

The certificate associated with this processing unit. It will identify
the processing unit to any internal or external services.

===== `datapathType` `enum(Default | Aporeto | EnvoyAuthorizer)` [`autogenerated`,`read_only`]

The datapath type that this processing unit must implement according to
the rendered policy: - `Default`: This policy is not making a decision
for the datapath. - `Aporeto`: The defender is managing and handling the
datapath. - `EnvoyAuthorizer`: The defender is serving Envoy-compatible
gRPC APIs that for example can be used by an Envoy proxy to use the
Segment PKI and implement Segment network policies. NOTE: The defender
is not owning the datapath in this case. It is merely providing an
authorizer API.

===== `dependendServices` link:#service[`[]service`]

The list of services that this processing unit depends on.

===== `egressPolicies` `_rendered_policy` [`autogenerated`,`read_only`]

Lists all the egress policies attached to processing unit.

===== `exposedServices` link:#service[`[]service`]

The list of services that this processing unit is implementing.

===== `hashedTags` `map[string]string` [`autogenerated`,`read_only`]

Contains the list of tags that matched the policies and their hashes.

===== `ingressPolicies` `_rendered_policy` [`autogenerated`,`read_only`]

Lists all the ingress policies attached to the processing unit.

===== `matchingTags` `[]string` [`autogenerated`,`read_only`]

Contains the list of tags that matched the policies.

===== `processingUnit` link:#processingunit[`processingunit`] [`required`,`creation_only`]

Can be set during a `POST` operation to render a policy on a processing
unit that has not been created yet.

===== `processingUnitID` `string` [`autogenerated`,`read_only`]

Identifier of the processing unit.

===== `scopes` `[]string`

The set of scopes granted to this processing unit that has to be present
in HTTP requests.
